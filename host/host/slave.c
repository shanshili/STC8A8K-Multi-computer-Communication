#include "8A8Ksdcc.h"
/*
中断x调用串口接收数据
*/

void UART1() __interrupt (4) __using (1) //串口1中断服务函数
{
    ES = 0; //关闭串口1中断
    if(RI) //再次判断，是否接收到地址数据(接收到数据后，RI会置1，需手动清0)
    {
     //   RXData = SBUF;
        // if(RXstart) //判断是否接收到过本地址
        // {
        //     if(RXData != '$') //判断是否接收到 数据结束 标志 $
        //     {
        //         temp[j] = RXData; //没有接收到结束标志，正常保存数据至数组
        //         j++;
        //     }
        //     else //接收到 结束标志 $
        //     {
        //         RXstart= 0; //本次接收结束
        //         SM2 = 1; //重新 配置为：只接收地址 模式，下次发送TB8=1才中断
        //         j = 0;
        //     }
        // }
        // if(RXData == 1) //判断是否呼叫本机，地址范围：000 – 254(00 - FE)
        // {
        //     RXstart = 1; //开始接收数据
        //     SM2 = 0; //配置为：接收数据 模式
        // }
    }
    RI = 0; //清除接收标志位
    ES = 1; //重新开启串口1中断
}

//从机串口设置
void UartInit(void)		//9600bps@24.000MHz
{
    P_SW1 = 0X00;       //端口映射
    SCON = 0xF0;		//串口控制：串口1，9位数据,可变波特率  1111 0000 允许串口接收数据，筛选地址帧,RB8=1为地址帧，地址信息可以进入SBUF并使RI为1，进而在中断服务程序中再进行地址号比较；
	PCON &= 0x7F;		//电源管理：波特率不倍速 PCON=0X00 SMOD=0
    AUXR &= 0xFE;		//选择波特率发生器：定时器1
	AUXR |= 0x40;		//定时器1时钟：Fosc,即1T T1x12=1
	TMOD &= 0x0F;		//定时器1模式配置：定时，16位自动重装方式
	TL1 = 0x8F;		//设定定时低字节: 
	TH1 = 0xFD;		//设定定时高字节:  64911 65536-(SYSCLK/4/baud)
	ET1 = 0;		//定时器1中断：禁止
    ES = 1;         //串口1中断: 开启
    TR1 = 1;        //启动定时器1
    EA = 1;         //中断 总开关
	TR1 = 1;		//启动定时器1
}

void main()
{
    UartInit();
    SADDR = 0X01;
    SADEN = 0X0F;
    while (1); 
}